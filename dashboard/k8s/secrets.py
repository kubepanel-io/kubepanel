"""
Kubernetes Secrets Operations

Read and update secrets from Kubernetes.
Secrets are initially generated by the operator, but Django can update
passwords when users request password changes.
"""

from kubernetes.client.rest import ApiException
import base64
import logging
import legacycrypt as crypt
from typing import Optional

from .client import get_core_api, handle_api_exception

logger = logging.getLogger(__name__)


def _b64encode(value: str) -> str:
    """Base64 encode a string for K8s secret data."""
    return base64.b64encode(value.encode('utf-8')).decode('utf-8')


def _generate_shadow_hash(password: str) -> str:
    """Generate a shadow-compatible password hash."""
    salt = crypt.mksalt(crypt.METHOD_SHA512)
    return crypt.crypt(password, salt)


def _generate_shadow_line(username: str, password_hash: str) -> str:
    """Generate a shadow file line for a user."""
    # Format: username:password_hash:lastchange:min:max:warn:inactive:expire:reserved
    return f"{username}:{password_hash}:19000:0:99999:7:::"


def get_secret_value(
    name: str,
    namespace: str,
    key: str
) -> Optional[str]:
    """
    Get a secret value from Kubernetes.
    
    Args:
        name: Secret name
        namespace: Secret namespace
        key: Key within the secret data
    
    Returns:
        Decoded secret value, or None if not found
    
    Raises:
        K8sNotFoundError: If secret not found
        K8sClientError: For other K8s errors
    """
    core_api = get_core_api()
    
    try:
        secret = core_api.read_namespaced_secret(name=name, namespace=namespace)
        
        if secret.data and key in secret.data:
            # Secret data is base64 encoded
            return base64.b64decode(secret.data[key]).decode('utf-8')
        
        logger.warning(f"Key '{key}' not found in secret '{namespace}/{name}'")
        return None
        
    except ApiException as e:
        handle_api_exception(e, f"Secret '{namespace}/{name}'")


def get_secret_from_ref(secret_ref: dict) -> Optional[str]:
    """
    Get a secret value using a secretRef dict.
    
    Args:
        secret_ref: Dict with 'name', 'namespace', and 'key'
    
    Returns:
        Decoded secret value, or None if ref is invalid
    """
    if not secret_ref:
        return None
    
    name = secret_ref.get('name')
    namespace = secret_ref.get('namespace')
    key = secret_ref.get('key')
    
    if not all([name, namespace, key]):
        logger.warning(f"Invalid secret ref: {secret_ref}")
        return None
    
    return get_secret_value(name, namespace, key)


def get_sftp_password(domain_status) -> Optional[str]:
    """
    Get SFTP password for a domain from its status.
    
    Args:
        domain_status: DomainStatus object
    
    Returns:
        SFTP password or None
    """
    secret_ref = domain_status.sftp_password_secret_ref
    return get_secret_from_ref(secret_ref)


def get_database_password(domain_status) -> Optional[str]:
    """
    Get database password for a domain from its status.

    Args:
        domain_status: DomainStatus object

    Returns:
        Database password or None
    """
    secret_ref = domain_status.database_password_secret_ref
    return get_secret_from_ref(secret_ref)


def update_secret_keys(
    name: str,
    namespace: str,
    updates: dict[str, str]
) -> None:
    """
    Update specific keys in a Kubernetes secret.

    Args:
        name: Secret name
        namespace: Secret namespace
        updates: Dict of key -> value pairs to update (values will be base64 encoded)

    Raises:
        K8sNotFoundError: If secret not found
        K8sClientError: For other K8s errors
    """
    core_api = get_core_api()

    try:
        # First read the existing secret
        secret = core_api.read_namespaced_secret(name=name, namespace=namespace)

        # Update the specified keys
        if secret.data is None:
            secret.data = {}

        for key, value in updates.items():
            secret.data[key] = _b64encode(value)

        # Patch the secret
        core_api.replace_namespaced_secret(name=name, namespace=namespace, body=secret)
        logger.info(f"Updated secret '{namespace}/{name}' keys: {list(updates.keys())}")

    except ApiException as e:
        handle_api_exception(e, f"Secret '{namespace}/{name}'")


def update_sftp_password(
    namespace: str,
    new_password: str,
    username: str = 'webuser'
) -> None:
    """
    Update SFTP password in the sftp-credentials secret.

    Updates both the plaintext password and the shadow hash.

    Args:
        namespace: Domain namespace (e.g., 'dom-example-com')
        new_password: The new password
        username: SFTP username (default: 'webuser')

    Raises:
        K8sNotFoundError: If secret not found
        K8sClientError: For other K8s errors
    """
    password_hash = _generate_shadow_hash(new_password)
    shadow_line = _generate_shadow_line(username, password_hash)

    update_secret_keys(
        name='sftp-credentials',
        namespace=namespace,
        updates={
            'password': new_password,
            'shadow': shadow_line,
        }
    )
    logger.info(f"Updated SFTP password for namespace '{namespace}'")


def update_database_password(
    namespace: str,
    new_password: str
) -> None:
    """
    Update database password in the db-credentials secret.

    Note: This only updates the K8s secret. The caller is responsible for
    also updating the actual MariaDB user password.

    Args:
        namespace: Domain namespace (e.g., 'dom-example-com')
        new_password: The new password

    Raises:
        K8sNotFoundError: If secret not found
        K8sClientError: For other K8s errors
    """
    update_secret_keys(
        name='db-credentials',
        namespace=namespace,
        updates={
            'password': new_password,
        }
    )
    logger.info(f"Updated database password in secret for namespace '{namespace}'")
