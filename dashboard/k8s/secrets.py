"""
Kubernetes Secrets Operations

Read and update secrets from Kubernetes.
Secrets are initially generated by the operator, but Django can update
passwords when users request password changes.
"""

from kubernetes.client.rest import ApiException
import base64
import logging
import legacycrypt as crypt
from typing import Optional
from datetime import datetime, timezone
from dataclasses import dataclass

from .client import get_core_api, handle_api_exception

logger = logging.getLogger(__name__)


def _b64encode(value: str) -> str:
    """Base64 encode a string for K8s secret data."""
    return base64.b64encode(value.encode('utf-8')).decode('utf-8')


def _generate_shadow_hash(password: str) -> str:
    """Generate a shadow-compatible password hash."""
    salt = crypt.mksalt(crypt.METHOD_SHA512)
    return crypt.crypt(password, salt)


def _generate_shadow_line(username: str, password_hash: str) -> str:
    """Generate a shadow file line for a user."""
    # Format: username:password_hash:lastchange:min:max:warn:inactive:expire:reserved
    return f"{username}:{password_hash}:19000:0:99999:7:::"


def get_secret_value(
    name: str,
    namespace: str,
    key: str
) -> Optional[str]:
    """
    Get a secret value from Kubernetes.
    
    Args:
        name: Secret name
        namespace: Secret namespace
        key: Key within the secret data
    
    Returns:
        Decoded secret value, or None if not found
    
    Raises:
        K8sNotFoundError: If secret not found
        K8sClientError: For other K8s errors
    """
    core_api = get_core_api()
    
    try:
        secret = core_api.read_namespaced_secret(name=name, namespace=namespace)
        
        if secret.data and key in secret.data:
            # Secret data is base64 encoded
            return base64.b64decode(secret.data[key]).decode('utf-8')
        
        logger.warning(f"Key '{key}' not found in secret '{namespace}/{name}'")
        return None
        
    except ApiException as e:
        handle_api_exception(e, f"Secret '{namespace}/{name}'")


def get_secret_from_ref(secret_ref: dict) -> Optional[str]:
    """
    Get a secret value using a secretRef dict.
    
    Args:
        secret_ref: Dict with 'name', 'namespace', and 'key'
    
    Returns:
        Decoded secret value, or None if ref is invalid
    """
    if not secret_ref:
        return None
    
    name = secret_ref.get('name')
    namespace = secret_ref.get('namespace')
    key = secret_ref.get('key')
    
    if not all([name, namespace, key]):
        logger.warning(f"Invalid secret ref: {secret_ref}")
        return None
    
    return get_secret_value(name, namespace, key)


def get_sftp_password(domain_status) -> Optional[str]:
    """
    Get SFTP password for a domain from its status.
    
    Args:
        domain_status: DomainStatus object
    
    Returns:
        SFTP password or None
    """
    secret_ref = domain_status.sftp_password_secret_ref
    return get_secret_from_ref(secret_ref)


def get_database_password(domain_status) -> Optional[str]:
    """
    Get database password for a domain from its status.

    Args:
        domain_status: DomainStatus object

    Returns:
        Database password or None
    """
    secret_ref = domain_status.database_password_secret_ref
    return get_secret_from_ref(secret_ref)


def update_secret_keys(
    name: str,
    namespace: str,
    updates: dict[str, str]
) -> None:
    """
    Update specific keys in a Kubernetes secret.

    Args:
        name: Secret name
        namespace: Secret namespace
        updates: Dict of key -> value pairs to update (values will be base64 encoded)

    Raises:
        K8sNotFoundError: If secret not found
        K8sClientError: For other K8s errors
    """
    core_api = get_core_api()

    try:
        # First read the existing secret
        secret = core_api.read_namespaced_secret(name=name, namespace=namespace)

        # Update the specified keys
        if secret.data is None:
            secret.data = {}

        for key, value in updates.items():
            secret.data[key] = _b64encode(value)

        # Patch the secret
        core_api.replace_namespaced_secret(name=name, namespace=namespace, body=secret)
        logger.info(f"Updated secret '{namespace}/{name}' keys: {list(updates.keys())}")

    except ApiException as e:
        handle_api_exception(e, f"Secret '{namespace}/{name}'")


def update_sftp_password(
    namespace: str,
    new_password: str,
    username: str = 'webuser'
) -> None:
    """
    Update SFTP password in the sftp-credentials secret.

    Updates both the plaintext password and the shadow hash.

    Args:
        namespace: Domain namespace (e.g., 'dom-example-com')
        new_password: The new password
        username: SFTP username (default: 'webuser')

    Raises:
        K8sNotFoundError: If secret not found
        K8sClientError: For other K8s errors
    """
    password_hash = _generate_shadow_hash(new_password)
    shadow_line = _generate_shadow_line(username, password_hash)

    update_secret_keys(
        name='sftp-credentials',
        namespace=namespace,
        updates={
            'password': new_password,
            'shadow': shadow_line,
        }
    )
    logger.info(f"Updated SFTP password for namespace '{namespace}'")


def update_database_password(
    namespace: str,
    new_password: str
) -> None:
    """
    Update database password in the db-credentials secret.

    Note: This only updates the K8s secret. The caller is responsible for
    also updating the actual MariaDB user password.

    Args:
        namespace: Domain namespace (e.g., 'dom-example-com')
        new_password: The new password

    Raises:
        K8sNotFoundError: If secret not found
        K8sClientError: For other K8s errors
    """
    update_secret_keys(
        name='db-credentials',
        namespace=namespace,
        updates={
            'password': new_password,
        }
    )
    logger.info(f"Updated database password in secret for namespace '{namespace}'")


def create_dkim_secret(
    name: str,
    namespace: str,
    private_key: str,
    public_key: str,
    dns_record: str,
    selector: str = "default"
) -> None:
    """
    Create a DKIM credentials secret in Kubernetes.

    This is called by Django when creating a new domain, before the
    Domain CR is created. The operator will read this secret to
    configure OpenDKIM.

    Args:
        name: Secret name (e.g., 'dkim-example-com')
        namespace: Namespace to create secret in (typically 'kubepanel')
        private_key: PEM-encoded RSA private key
        public_key: Base64-encoded public key
        dns_record: Complete DKIM DNS TXT record value
        selector: DKIM selector name (default 'default')

    Raises:
        K8sClientError: For K8s API errors
    """
    from kubernetes.client import V1Secret, V1ObjectMeta

    core_api = get_core_api()

    secret = V1Secret(
        api_version="v1",
        kind="Secret",
        metadata=V1ObjectMeta(
            name=name,
            namespace=namespace,
            labels={
                "app.kubernetes.io/managed-by": "kubepanel",
                "kubepanel.io/type": "dkim",
            }
        ),
        type="Opaque",
        string_data={
            "selector": selector,
            "private-key": private_key,
            "public-key": public_key,
            "dns-txt-record": dns_record,
        }
    )

    try:
        core_api.create_namespaced_secret(namespace=namespace, body=secret)
        logger.info(f"Created DKIM secret '{namespace}/{name}'")
    except ApiException as e:
        if e.status == 409:
            # Secret already exists, update it
            logger.info(f"DKIM secret '{namespace}/{name}' already exists, updating")
            update_secret_keys(
                name=name,
                namespace=namespace,
                updates={
                    "selector": selector,
                    "private-key": private_key,
                    "public-key": public_key,
                    "dns-txt-record": dns_record,
                }
            )
        else:
            handle_api_exception(e, f"Secret '{namespace}/{name}'")


@dataclass
class CertificateInfo:
    """Information about a TLS certificate."""
    exists: bool = False
    subject: Optional[str] = None
    issuer: Optional[str] = None
    not_before: Optional[datetime] = None
    not_after: Optional[datetime] = None
    days_until_expiry: Optional[int] = None
    serial_number: Optional[str] = None
    status: str = 'unknown'  # valid, expiring_soon, expired, not_yet_valid, not_found, error
    status_message: str = ''
    error: Optional[str] = None


def get_tls_certificate_info(domain_name: str, namespace: str) -> CertificateInfo:
    """
    Get TLS certificate information from Kubernetes secret.

    Args:
        domain_name: The domain name (e.g., 'example.com')
        namespace: The domain namespace (e.g., 'dom-example-com')

    Returns:
        CertificateInfo with certificate details
    """
    # TLS secret name follows pattern: example-com-tls (domain with dots replaced by dashes)
    secret_name = domain_name.replace('.', '-') + '-tls'

    try:
        # Get the certificate PEM from the secret
        cert_pem = get_secret_value(
            name=secret_name,
            namespace=namespace,
            key='tls.crt'
        )

        if not cert_pem:
            return CertificateInfo(
                exists=False,
                status='not_found',
                status_message='Certificate not found or not yet provisioned'
            )

        # Parse the certificate using cryptography library
        try:
            from cryptography import x509
            from cryptography.hazmat.backends import default_backend
        except ImportError:
            return CertificateInfo(
                exists=True,
                status='error',
                status_message='cryptography library not available',
                error='cryptography library not installed'
            )

        # Load the certificate
        cert = x509.load_pem_x509_certificate(cert_pem.encode(), default_backend())

        # Extract subject and issuer
        subject = cert.subject.rfc4514_string()
        issuer = cert.issuer.rfc4514_string()

        # Get validity dates
        not_before = cert.not_valid_before_utc
        not_after = cert.not_valid_after_utc

        # Calculate days until expiry
        now = datetime.now(timezone.utc)
        days_until_expiry = (not_after - now).days

        # Determine status
        if now < not_before:
            status = 'not_yet_valid'
            status_message = f'Certificate not yet valid (starts {not_before.strftime("%Y-%m-%d")})'
        elif now > not_after:
            status = 'expired'
            status_message = f'Certificate expired on {not_after.strftime("%Y-%m-%d")}'
        elif days_until_expiry <= 7:
            status = 'expiring_soon'
            status_message = f'Certificate expires in {days_until_expiry} days!'
        elif days_until_expiry <= 30:
            status = 'expiring_soon'
            status_message = f'Certificate expires in {days_until_expiry} days'
        else:
            status = 'valid'
            status_message = f'Certificate valid for {days_until_expiry} days'

        # Get serial number (as hex string)
        serial_hex = format(cert.serial_number, 'x').upper()

        return CertificateInfo(
            exists=True,
            subject=subject,
            issuer=issuer,
            not_before=not_before,
            not_after=not_after,
            days_until_expiry=days_until_expiry,
            serial_number=serial_hex,
            status=status,
            status_message=status_message
        )

    except Exception as e:
        logger.warning(f"Failed to get TLS certificate for {domain_name}: {e}")
        return CertificateInfo(
            exists=False,
            status='error',
            status_message='Failed to retrieve certificate',
            error=str(e)
        )
